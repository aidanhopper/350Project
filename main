#!venv/bin/python3

from pyeda.inter import expr
from pyeda.inter import expr2bdd
from pyeda.inter import bddvars
from pyeda.inter import bddvar
from pyeda.boolalg.bdd import BDDZERO


def ints_to_true_bin_values(li, comparison):
    ret = []
    for i in li:
        for j in li:
            if comparison(i, j):
                s = format(i, '05b')
                s += format(j, '05b')
                ret.append(s)
    return ret


def create_RR():

    truevalues = ints_to_true_bin_values(
        list(range(32)),
        lambda i, j: (i + 3) % 32 == j % 32 or (i + 8) % 32 == j % 32
    )

    # build string using truevalues
    expression = ""
    map = ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j']
    for s in truevalues:
        for i, c in enumerate(s):
            if c == '0':
                expression += "~" + map[i] + " "
            else:
                expression += map[i] + " "
            if i == 9:
                expression += "| "
            else:
                expression += "& "
    expression = expression[:-2]  # truncate the end

    f = expr(expression)
    return expr2bdd(f)


def create_EVEN():

    truevalues = []
    for i in range(16):
        s = format(i*2, '05b')
        truevalues.append(s)

    # build string using truevalues
    expression = ""
    map = ['a', 'b', 'c', 'd', 'e']
    for s in truevalues:
        for i, c in enumerate(s):
            if c == '0':
                expression += "~" + map[i] + " "
            else:
                expression += map[i] + " "
            if i == 4:
                expression += "| "
            else:
                expression += "& "
    expression = expression[:-2]  # truncate the end

    f = expr(expression)
    return expr2bdd(f)


def create_PRIME():
    li = [3, 5, 7, 11, 13, 17, 19, 23, 29, 31]
    truevalues = []
    for i in li:
        s = format(i, '05b')
        truevalues.append(s)

    # build string using truevalues
    expression = ""
    map = ['a', 'b', 'c', 'd', 'e']
    for s in truevalues:
        for i, c in enumerate(s):
            if c == '0':
                expression += "~" + map[i] + " "
            else:
                expression += map[i] + " "
            if i == 4:
                expression += "| "
            else:
                expression += "& "
    expression = expression[:-2]  # truncate the end

    f = expr(expression)
    return expr2bdd(f)


def to_bdd(*argv):
    binary_value = ""
    for arg in argv:
        binary_value += format(arg, '05b')

    map = ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j']
    expression = ""
    for i, c in enumerate(binary_value):
        if c == '0':
            expression += "~" + map[i] + " "
        else:
            expression += map[i] + " "
        expression += "& "
    expression = expression[:-2]
    t = expr(expression)
    t = expr2bdd(t)
    return t


def satisfies(bdd, expression):
    return bdd.restrict(expression.satisfy_one())


def two_step_reachable(r1, r2):
    a, b, c, d, e, f, g, h, i, j = map(bddvar, 'abcdefghij')
    X = bddvars('x', 5)
    Y = bddvars('y', 5)
    Z = bddvars('z', 5)
    return (r1.compose({
        a: X[0], b: X[1], c: X[2], d: X[3], e: X[4],
        f: Z[0], g: Z[1], h: Z[2], i: Z[3], j: Z[4]
    }) & r2.compose({
        a: Z[0], b: Z[1], c: Z[2], d: Z[3], e: Z[4],
        f: Y[0], g: Y[1], h: Y[2], i: Y[3], j: Y[4]
    })).smoothing(Z).compose({
        X[0]: a, X[1]: b, X[2]: c, X[3]: d, X[4]: e,
        Y[0]: f, Y[1]: g, Y[2]: h, Y[3]: i, Y[4]: j
    })


if __name__ == '__main__':
    rr = create_RR()
    even = create_EVEN()
    prime = create_PRIME()

    assert satisfies(rr, to_bdd(27, 3))
    assert not satisfies(rr, to_bdd(16, 20))
    assert satisfies(even, to_bdd(14))
    assert not satisfies(even, to_bdd(13))
    assert satisfies(prime, to_bdd(7))
    assert not satisfies(prime, to_bdd(2))

    rr2 = two_step_reachable(rr, rr)

    assert satisfies(rr2, to_bdd(27, 6))
    assert not satisfies(rr2, to_bdd(27, 9))

    h = rr2
    i = 0
    rstar = BDDZERO
    while True:
        print("steps: " + str(i))
        i += 1
        hprime = h
        h = hprime | two_step_reachable(hprime, rr2)
        if h is hprime:
            break

    print(list(rstar.satisfy_all()))
    assert satisfies(rstar, to_bdd(0, 12))
